void EnhancedCalendarServiceImpl::ExecuteEnhancedCalendarRequest(
    mojom::EnhancedCalendarServiceRequestParamsPtr request_params,
    ExecuteEnhancedCalendarRequestCallback request_callback) {
  if (!web_state_) {
    mojom::EnhancedCalendarResponseResultPtr result_union =
        mojom::EnhancedCalendarResponseResult::NewError(
            "WebState destroyed before executing request");
    std::move(request_callback).Run(std::move(result_union));
    return;
  }

  // Create the base request and set the selected and surrounding texts.
  optimization_guide::proto::EnhancedCalendarRequest base_request;
  base_request.set_selected_text(request_params->selected_text);
  base_request.set_surrounding_text(request_params->surrounding_text);

  // Hardcoded prompt variations.
  std::vector<std::string> prompts = {
      "Find the event matching the selected text.",
      "What is the event corresponding to the selected text?",
      "Identify the event described in the selected text."
  };

  // Create a completion callback that will be executed once the PageContext proto is generated.
  auto page_context_completion_callback = base::BindOnce(
      &EnhancedCalendarServiceImpl::OnPageContextGeneratedMultiple,
      weak_ptr_factory_.GetWeakPtr(), std::move(base_request), prompts,
      std::move(request_callback));

  // Generate the PageContext proto asynchronously.
  page_context_wrapper_ = [[PageContextWrapper alloc]
      initWithWebState:web_state_.get()
      completionCallback:std::move(page_context_completion_callback)];
  [page_context_wrapper_ setShouldGetInnerText:YES];
  [page_context_wrapper_ setShouldGetSnapshot:YES];
  [page_context_wrapper_
      setTextToHighlight:base::SysUTF8ToNSString(request_params->surrounding_text)];
  [page_context_wrapper_ populatePageContextFieldsAsync];
}

void EnhancedCalendarServiceImpl::OnPageContextGeneratedMultiple(
    optimization_guide::proto::EnhancedCalendarRequest base_request,
    const std::vector<std::string>& prompts,
    std::unique_ptr<optimization_guide::proto::PageContext> page_context,
    ExecuteEnhancedCalendarRequestCallback request_callback) {
  // Clear the PageContext wrapper.
  page_context_wrapper_ = nil;

  // For each hardcoded prompt, create a copy of the base request, attach a deep copy
  // of the PageContext, and execute the model.
  for (const auto& prompt : prompts) {
    optimization_guide::proto::EnhancedCalendarRequest request_copy = base_request;
    request_copy.set_prompt(prompt);
    // Attach a deep copy of the PageContext.
    request_copy.set_allocated_page_context(page_context->NewDeepCopy().release());

    auto callback = base::BindOnce(
        [prompt, this](optimization_guide::OptimizationGuideModelExecutionResult result,
                       std::unique_ptr<optimization_guide::ModelQualityLogEntry> entry) mutable {
          // Convert the prompt to an NSString for logging.
          NSString* nsPrompt = [NSString stringWithUTF8String:prompt.c_str()];
          if (result.response.has_value()) {
            std::optional<optimization_guide::proto::EnhancedCalendarResponse> response_proto =
                optimization_guide::ParsedAnyMetadata<
                    optimization_guide::proto::EnhancedCalendarResponse>(
                        result.response.value());
            if (response_proto.has_value()) {
              // Log the successful response.
              NSString* responseString = [NSString stringWithUTF8String:
                  response_proto.value().DebugString().c_str()];
              NSLog(@"Response for prompt '%@': %@", nsPrompt, responseString);
            } else {
              NSLog(@"Response for prompt '%@': Proto unmarshalling error", nsPrompt);
            }
          } else {
            std::string error_string = base::StrCat({
                "Server model execution error: ",
                this->service_->ResponseForErrorCode(
                    static_cast<int>(result.response.error().error()))
            });
            NSLog(@"Response for prompt '%@': %s", nsPrompt, error_string.c_str());
          }
        });

    service_->ExecuteModel(
        optimization_guide::ModelBasedCapabilityKey::kEnhancedCalendar,
        request_copy,
        kEnhancedCalendarRequestTimeout,
        std::move(callback));
  }

  // Optionally, call the original callback with a dummy result.
  // This is to satisfy the method's signature; you can adjust as needed.
  mojom::EnhancedCalendarResponseResultPtr dummy_result =
      mojom::EnhancedCalendarResponseResult::NewResponse(
          mojo_base::ProtoWrapper(optimization_guide::proto::EnhancedCalendarResponse()));
  std::move(request_callback).Run(std::move(dummy_result));
}
